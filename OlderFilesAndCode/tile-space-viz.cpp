// tile-space-viz.cpp
// MMS, 1/4/15
// Quick and dirty to generate an input file for IterVis to visualize
// the tile space for diamond slab tiling.
//
// Usage:
//      // First edit the Li, Lj, Ui, Uj parameters as desired.
//      gcc -Wno-write-strings tile-space-viz.cpp -o tile-space-viz
//      ./tile-space-viz
//      // Then copy the output into the input.grfon file for IterVis. 
//
// The below loop was generated by iscc with the following input
/*
# We represent the iteration space for the loop in iscc as follows:
# Note that t will go from 1 to s=(tau/3)-2 to avoid pointy bits.
# TAU=33
Islab := [T, Li, Ui, Lj, Uj] -> { computation[t,i,j] :
                              1<=t<9 && Li<= i < Ui && Lj <= j < Uj };

# all 3 phases 
T_diamond_with_skew := {computation[t,i,j]  -> [thyme, k1, k2, t, i, j] :
    exists k0,r0,r1,r2: 0 <=r0<33 && 0<=r1<33 && 0<=r2<33
    && thyme=k0+k1+k2
    && 33*k0+r0 = t+i && 33*k1+r1 = t+j && 33*k2+r2 = t-i-j };
codegen (T_diamond_with_skew * Islab) assuming [Li,Ui,Lj,Uj] -> { : Li<Ui && Lj<
Uj};
*/
#include <stdio.h>
#include <stdlib.h>
#include "eassert.h"
#include "intops.h"

int main() {

    int c0, c1, c2;
    int Li = 0, Lj = 0;
    int Ui = 200, Uj = 200;
    int T = 200;
    int tau = 6;

    printf("=== New way to do diamond tiling parameterization, single tile\n");

    int thyme = 1;
    int k1=1;
    int k2=1;
    int t,i,j;

        // Loop over time within a tile.
        for (t=floord(thyme*tau,3); 
             t<= floord((3+thyme)*tau-3,3); t++) {

          // Loops over spatial dimensions within tile.
          for (i=max((thyme-k1-k2)*tau-t, 2*t-(2+k1+k2)*tau+2);
               i<=min((1+thyme-k1-k2)*tau-t-1, 2*t-(k1+k2)*tau); i++) {
            for (j=max(tau*k1-t,t-i-(1+k2)*tau+1);
                 j<=min((1+k1)*tau-t-1,t-i-k2*tau); j++) {
          printf("{ pos: %d %d %d; color: #FFFFFF }\n", t, i, j);
            } // for j
          } // for i
        } // for t

    /*
    printf("=== New way to do diamond tiling parameterization\n");
    int thyme, k1, k2;
    for (thyme=floord(6,tau-3); thyme<=floord(3*T,tau); thyme++) {
      // might want bounding box for k2 so can do collapse
      for (k1=floord((3*Lj+(thyme-2)*tau+2),(3*tau)); 
           k1<=floord((3*Uj+(2+thyme)*tau-1),(3*tau)); k1++) {
        for (k2= floord(((2*thyme-2-3*k1)*tau +2-3*Ui),(3*tau));
             k2<= floord(((2+2*thyme-3*k1)*tau -2-3*Li),(3*tau)); k2++) {
          printf("{ pos: %d %d %d; color: #FFFFFF }\n", thyme, k1, k2);
        }
      }
    }
    */

/*
    printf("==== Code from Jacobi2D-DiamondSlabISCCParam-OMP.test.c\n");

    for (int c0 = -2; c0 <= 0; c0 += 1){

      // Two loops over tiles within one phase.
      // All of the tiles within one phase can be done in parallel.

      // updates by Dave W, to the c1 and c2 loops, for OpenMP 
      // (from here to the end of the #if BOUNDING_BOX_FOR_PARALLEL_LOOPS
      //   hoist out min_c1 and max_c1, then use that to hoist a bounding box for c2
      //   initial version is just aiming for correct and parallel, 
      //   without worrying about a loose boundingbox
      int c1_lb =
            max(
              max(
                floord(Lj + (tau/3) * c0 + (tau/3), tau),
                c0 + floord(-2 * T + Lj - 1, tau) + 1),
              floord(Lj + 1, tau)
            ); // end init block c1
      int c1_ub =
            min(
              min(
                floord(Uj + (tau/3) * c0 - ((tau/3)+2), tau) + 1,
                floord(T + Uj - 1, tau)),
              c0 + floord(Uj - 5, tau) + 2
            ); // end cond block c1

      // The two expressions below are the same as in the previous version, except that
      //  in the c2_lb_min_expr, I have replaced c1 with:
      //    c1_min_value where it appears with a positive coefficient, and
      //    c1_max_value where it appears with a negative coefficient.
      //  and in the c2_ub_max_expr, the opposite (i.e., c1 becomes c1_max_value where 
      //  positive).
      ///  Note that I assume tau > 0
#define c2_lb_min_expr(c1_min_value, c1_max_value)              \
        max( \
          max( \
            max( \
              max( \
                max( \
                  max( \
                    c0 - 2 * c1_max_value + floord(-Ui + Lj + 1,tau),  \
                    -c1_max_value + floord(-2 * Ui - Uj + tau * c0 + tau * c1_min_value \
                        - tau-3, tau*2)+1), \
                  c1_min_value + floord(-Ui - 2 * Uj + 3, tau)), \
                floord(-Ui - Uj + 3, tau)),  \
              c0 - c1_max_value + floord(-Ui - (tau/3) * c0 + ((tau/3)+1), tau)),  \
            c0 - c1_max_value + floord(-T - Ui, tau) + 1),  \
          -c1_max_value + floord(-Ui + 4, tau) - 1 \
        ) // end init block c2 

#define c2_ub_max_expr(c1_min_value, c1_max_value)              \
        min( \
          min( \
            min( \
              min( \
                min( \
                  min( \
                    c0 - 2 * c1_min_value + floord(-Li + Uj - 2, tau) + 1,  \
                    c0 - c1_min_value + floord(-Li - 2, tau) + 1),  \
                  c0 - c1_min_value + floord(-Li - (tau/3) * c0 - ((tau/3)+1), tau) + 1), \
                floord(T - Li - Lj, tau)), \
              -c1_min_value + floord(2 * T - Li, tau)),  \
            c1_max_value + floord(-Li - 2 * Lj - 1, tau) + 1),  \
          -c1_min_value + floord(-2 * Li - Lj + tau * c0 + tau * c1_max_value + (tau-1), tau*2) \
        ) // end cond block c2 
#define c2_lb_expr(c1_value) c2_lb_min_expr(c1_value, c1_value)
#define c2_ub_expr(c1_value) c2_ub_max_expr(c1_value, c1_value)


      for (int c1 = c1_lb; c1 <= c1_ub; c1 += 1) {
        for (int c2 = c2_lb_expr(c1); c2 <= c2_ub_expr(c1); c2 += 1) {
            printf("{ pos: %d %d %d; color: #FFFFFF }\n", c0, c1, c2);
        }
      }
    }
*/

/*
    printf("==== Specializing the c1 and c2 bounds for slab\n");
    // It does cut down on the bounds a bit.

    for (int c0 = -2; c0 <= 0; c0 += 1){

      // Two loops over tiles within one phase.
      // All of the tiles within one phase can be done in parallel.

      // updates by Dave W, to the c1 and c2 loops, for OpenMP 
      // (from here to the end of the #if BOUNDING_BOX_FOR_PARALLEL_LOOPS
      //   hoist out min_c1 and max_c1, then use that to hoist a bounding box for c2
      //   initial version is just aiming for correct and parallel, 
      //   without worrying about a loose boundingbox
      int c1_lb =
            max(
              max(
                floord(Lj + (tau/3) * c0 + (tau/3), tau),
                c0 + floord(-2 * ((tau/3)-2) + Lj - 1, tau) + 1),
              floord(Lj + 1, tau)
            ); // end init block c1
      int c1_ub =
            min(
              floord(Uj - ((tau/3)-3), tau),
              c0 + floord(Uj - 5, tau) + 2
            ); // end cond block c1

      // The two expressions below are the same as in the previous version, except that
      //  in the c2_lb_min_expr, I have replaced c1 with:
      //    c1_min_value where it appears with a positive coefficient, and
      //    c1_max_value where it appears with a negative coefficient.
      //  and in the c2_ub_max_expr, the opposite (i.e., c1 becomes c1_max_value where 
      //  positive).
      ///  Note that I assume tau > 0
#define c2_lb_min_expr(c1_min_value, c1_max_value)              \
        max( \
          max( \
            max( \
              max( \
                max( \
                  c0 - 2 * c1_max_value + floord(-Ui + Lj + 1,tau),  \
                  -c1_max_value + floord(-2 * Ui - Uj + tau * c0 + \
                      tau * c1_min_value - tau-3, tau*2)+1), \
                c1_min_value + floord(-Ui - 2 * Uj + 3, tau)), \
              floord(-Ui - Uj + 3, tau)),  \
            c0 - c1_max_value + floord(-((tau/3)-2) - Ui, tau) + 1),  \
          -c1_max_value + floord(-Ui + 4, tau) - 1 \
        ) // end init block c2 

#define c2_ub_max_expr(c1_min_value, c1_max_value)              \
        min( \
          min( \
            min( \
              min( \
                min( \
                  min( \
                    c0 - 2 * c1_min_value + floord(-Li + Uj - 2, tau) + 1,  \
                    c0 - c1_min_value + floord(-Li - 2, tau) + 1),  \
                  c0 - c1_min_value + floord(-Li - (tau/3) * c0 - ((tau/3)+1), tau) + 1), \
                floord(((tau/3)-2) - Li - Lj, tau)), \
              -c1_min_value + floord(2 * ((tau/3)-2) - Li, tau)),  \
            c1_max_value + floord(-Li - 2 * Lj - 1, tau) + 1),  \
          -c1_min_value + floord(-2 * Li - Lj + tau * c0 + tau * c1_max_value + (tau-1), tau*2) \
        ) // end cond block c2
#define c2_lb_expr(c1_value) c2_lb_min_expr(c1_value, c1_value)
#define c2_ub_expr(c1_value) c2_ub_max_expr(c1_value, c1_value)


      for (int c1 = c1_lb; c1 <= c1_ub; c1 += 1) {
        for (int c2 = c2_lb_expr(c1); c2 <= c2_ub_expr(c1); c2 += 1) {
            printf("{ pos: %d %d %d; color: #FFFFFF }\n", c0, c1, c2);
        }
      }
    }
*/

    printf("==== Doing unskew\n");
    // It does cut down on the bounds a bit.

    for (int c0 = -2; c0 <= 0; c0 += 1){

      // Two loops over tiles within one phase.
      // All of the tiles within one phase can be done in parallel.

      // updates by Dave W, to the c1 and c2 loops, for OpenMP 
      // (from here to the end of the #if BOUNDING_BOX_FOR_PARALLEL_LOOPS
      //   hoist out min_c1 and max_c1, then use that to hoist a bounding box for c2
      //   initial version is just aiming for correct and parallel, 
      //   without worrying about a loose boundingbox
      int c1_lb =
            max(
              max(
                floord(Lj + (tau/3) * c0 + (tau/3), tau),
                c0 + floord(-2 * ((tau/3)-2) + Lj - 1, tau) + 1),
              floord(Lj + 1, tau)
            ); // end init block c1
      int c1_ub =
            min(
              floord(Uj - ((tau/3)-3), tau),
              c0 + floord(Uj - 5, tau) + 2
            ); // end cond block c1

      // The two expressions below are the same as in the previous version, except that
      //  in the c2_lb_min_expr, I have replaced c1 with:
      //    c1_min_value where it appears with a positive coefficient, and
      //    c1_max_value where it appears with a negative coefficient.
      //  and in the c2_ub_max_expr, the opposite (i.e., c1 becomes c1_max_value where 
      //  positive).
      ///  Note that I assume tau > 0
      // Just going to add c1_min_value into all?
      // No do the addition of c1 into all bounds before doing min and max stuff.
#define c2_lb_min_expr(c1_min_value, c1_max_value)              \
        max( \
          max( \
            max( \
              max( \
                max( \
                  c0 - c1_max_value + floord(-Ui + Lj + 1,tau),  \
                  floord(-2 * Ui - Uj + tau * c0 + \
                      (tau+1) * c1_min_value - tau-3, tau*2)+1), \
                2*c1_min_value + floord(-Ui - 2 * Uj + 3, tau)), \
              floord(-Ui - Uj + 3, tau)),  \
            c0 + floord(-((tau/3)-2) - Ui, tau) + 1),  \
          floord(-Ui + 4, tau) - 1 \
        ) // end init block c2 

#define c2_ub_max_expr(c1_min_value, c1_max_value)              \
        min( \
          min( \
            min( \
              min( \
                min( \
                  min( \
                    c0 - c1_min_value + floord(-Li + Uj - 2, tau) + 1,  \
                    c0  + floord(-Li - 2, tau) + 1),  \
                  c0 + floord(-Li - (tau/3) * c0 - ((tau/3)+1), tau) + 1), \
                floord(((tau/3)-2) - Li - Lj, tau)), \
              floord(2 * ((tau/3)-2) - Li, tau)),  \
            2*c1_max_value + floord(-Li - 2 * Lj - 1, tau) + 1),  \
          floord(-2 * Li - Lj + tau * c0 + tau * c1_max_value + (tau-1), tau*2) \
        ) // end cond block c2
#define c2_lb_expr(c1_value) c2_lb_min_expr(c1_value, c1_value)
#define c2_ub_expr(c1_value) c2_ub_max_expr(c1_value, c1_value)


      for (int c1 = c1_lb; c1 <= c1_ub; c1 += 1) {
        for (int c2 = c2_lb_expr(c1); c2 <= c2_ub_expr(c1); c2 += 1) {
            printf("{ pos: %d %d %d; color: #FFFFFF }\n", c0, c1, c2);
        }
      }
    }

/*    for (int c0 = -2; c0 <= 0; c0 += 1) {
        for (int c1 = max(floord(Lj + 1, 33), c0 + floord(Lj + 16, 33)); c1 <= min(floord(Uj + 7, 33), c0 + floord(Uj - 5, 33) + 2); c1 += 1) {
            for (int c2 = max(max(max(max(max(c0 - 2 * c1 + floord(-Ui + Lj + 1, 33), -c1 + floord(-2 * Ui - Uj + 33 * c0 + 33 * c1 - 30, 66) + 1), c1 + floord(-Ui - 2 * Uj + 3, 33)), floord(-Ui - Uj + 3, 33)), c0 - c1 + floord(-Ui - 8, 33) + 1), -c1 + floord(-Ui + 4, 33) - 1); c2 <= min(min(min(min(min(-c1 + floord(-2 * Li - Lj + 33 * c0 + 33 * c1 + 32, 66), c0 - 2 * c1 + floord(-Li + Uj - 2, 33) + 1), c0 - c1 + floord(-Li - 2, 33) + 1), -c1 + floord(-Li + 16, 33)), floord(-Li - Lj + 8, 33)), c1 + floord(-Li - 2 * Lj - 1, 33) + 1); c2 += 1) {

                //std::cout << "{ pos: " << c0 << " " << c1 << " " << c2 
                //          << "; color: #000000 }" << std::endl;
                printf("{ pos: %d %d %d; color: #FFFFFF }\n", c0, c1, c2);

            }
        }
    }
    
    printf("\n\nSIMPLER LOOPS\n");
    int tau = 33;

    // loops over bottom left, middle, top right
    for (int c0 = -2; c0<=0; c0+=1){
      // loops horizontally?
      for (int c1 = 0; c1 <= (Uj+tau-3)/(tau-3) ; c1 += 1){
         // loops vertically?, but without skew
        for (int x = (-Ui-tau+2)/(tau-3); x<=0 ; x += 1){
          int c2 = x-c1; //skew
                printf("{ pos: %d %d %d; color: #FFFFFF }\n", c0, c1, c2);

            }
        }
    }
*/

/*
    printf("\n\nUnskewed c2 in iscc and then got projection\n");
    tau = 33;
    int T = 9;  // is this correct?

    // loops over bottom left, middle, top right
    for (int c0 = -2; c0<=0; c0+=1){
        // c1 bounds
        int c1_lb =
            max(
              max(
                floord(Lj + (tau/3) * c0 + (tau/3), tau),
                c0 + floord(-2 * T + Lj - 1, tau) + 1),
              floord(Lj + 1, tau)
            ); // end init block c1
        int c1_ub =
            min(
              min(
                floord(Uj + (tau/3) * c0 - ((tau/3)+2), tau) + 1,
                floord(T + Uj - 1, tau)),
              c0 + floord(Uj - 5, tau) + 2
            ); // end cond block c1
        for (int c1 = c1_lb; c1 <= c1_ub; c1 += 1) {
      
            // inner loop over tiles but without skew
            for (int x = floord(-Ui + 4, tau) - 1; 
                     x <= floord(-Li - (tau+4), tau) + 1; x += 1) {
                int c2 = x-c1; //skew
                printf("{ pos: %d %d %d; color: #FFFFFF }\n", c0, c1, c2);

            }
        }
    }
*/

    return 0;
}